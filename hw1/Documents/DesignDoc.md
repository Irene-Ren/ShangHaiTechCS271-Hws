# CS271 Spring 2021 Computer Graphics II

# HomeWork 1

**Name:** **任怡静**

**Student ID:2018533144**

**E-mail: renyj@shanghaitech.edu.cn**

### Problem 1: 3D convex hull algorithm

##### Implement a 3D convex hull algorithm (not limited to the ones in slides) with visualization. 

###### Data Structures

- For the input of 3D point cloud, the data structure looks like this:

- ```python
  class Point3D:
      def __init__(self,x,y,z):
          self.m_x = x
          self.m_y = y
          self.m_z = z
      def DotProduct(self, other):
          return self.m_x * other.m_x + self.m_y * other.m_y + self.m_z * other.m_z
      def CrossProduct(self, other):
          coord_x = self.m_y * other.m_z - self.m_z * other.m_y
          coord_y = self.m_z * other.m_x - self.m_x * other.m_z
          coord_z = self.m_x * other.m_y - self.m_y * other.m_x
          result = Point3D(coord_x, coord_y, coord_z)
          return result
      def Minus(self,other):
          p = Point3D(0,0,0)
          p.m_x = self.m_x - other.m_x
          p.m_y = self.m_y - other.m_y
          p.m_z = self.m_z - other.m_z
          return p
  ```

  - Members
    - In this data structure, **m_x**,  **m_y**, **m_z** represent the three dimensional coordinate for a 3D point or vector, all three of them are type **double**
  - Functions
    - The **Point3D** class support dot product, cross product and vector calculation

- For the Faces generated by algorithm for convex hull, the data structure looks like this:

- ```python
  class Face:
      def __init__(self, x, y, z, h):
          self.is_hull = h
          self.v1 = x
          self.v2 = y
          self.v3 = z
  ```

  - Members
    - **v1**, **v2**, **v3** represent the order of a face, if read in order, it will make sure it is always counterclockwise, all three of them are type **int**

- For final formed convex hull, the data structure looks like this:

- ```python
  class Convex3D:
      points = []
      def __init__(self):
          self.triangleF = []
      def DirectedVolume(self, p, f):
          vector1 = Point3D.Minus(self.points[f.v2], self.points[f.v1])
          vector2 = Point3D.Minus(self.points[f.v3], self.points[f.v1])
          vector3 = Point3D.Minus(p, self.points[f.v1])
          return Point3D.DotProduct(Point3D.CrossProduct(vector1, vector2), vector3)
      def CreateOriginTetrahedron(self):
          if len(self.points) < 4:
              print("Not enough points for 3D convexhull")
              return None
          success = False
          for i in range(1, len(self.points)):
              if Dist(self.points[0], self.points[i]) > ERROR:
                  self.points[1],self.points[i] = self.points[i], self.points[1]
                  success = True
                  print("Find two points")
                  break
          if not success:
              print("Same vertex for all in list")
              return None
          success = False
          for i in range(2, len(self.points)):
              if Area(self.points[0],self.points[1],self.points[i]) > ERROR:
                  self.points[2], self.points[i] = self.points[i], self.points[2]
                  success = True
                  print("Find three points")
                  break
          if not success:
              print("Same line for all in list")
              return None
          for i in range(3, len(self.points)):
              if Volume(self.points[0], self.points[1], self.points[2], self.points[i]) > ERROR:
                  self.points[3], self.points[i] = self.points[i], self.points[3]
                  success = True
                  print("Find Four Points")
                  break
          if not success:
              print("Same plane for all in list")
              return None
          else:
              originConv = Convex3D()
              for i in range(4):
                  face_tmp = Face((i+1)%4,(i+2)%4,(i+3)%4,True)
                  if self.DirectedVolume(self.points[i], face_tmp) > 0:
                      face_tmp.v2, face_tmp.v3 = face_tmp.v3, face_tmp.v2
                  originConv.triangleF.append(face_tmp)
              return originConv
      def CleanUp(self, insideFaces):
          insideF = []
          outsideF = []
          for face in insideFaces:
              insideF.append((face.v1, face.v2))
              insideF.append((face.v2, face.v3))
              insideF.append((face.v3, face.v1))
  
              outsideF.append((face.v2, face.v1))
              outsideF.append((face.v3, face.v2))
              outsideF.append((face.v1, face.v3))
          insideF = set(insideF)
          outsideF = set(outsideF)
          return insideF - outsideF
          
      def AddPointP(self, hull, p):
          visibleF = []
          for face in hull.triangleF:
              if self.DirectedVolume(self.points[p], face) > ERROR:
                  visibleF.append(face)
          for face in visibleF:
              hull.triangleF.remove(face)
          for edge in self.CleanUp(visibleF):
              newFace = Face(edge[0], edge[1], p, True)
              hull.triangleF.append(newFace)
      def ExtendConvexHull(self):
          hull = self.CreateOriginTetrahedron()
          if hull is not None:
              for i in range(4, len(self.points)):
                  self.AddPointP(hull, i)
          return hull
  ```

  - Members
    - **points** is the list of points read from input, prepare for calculation, type **List<Point3D>**
    - **triangleF** is the list of faces calculated by **Convex3D** functions, will be updated if some faces are covered by others, type **List<Face>**
  - Functions
    - **DirectedVolume()** will calculate the directed volume of point **p** and face **f**, return **double**
    - **CreateOriginTetrahedron()** will form the original tetrahedron for incremental algorithm, it will check through **points** list and find the first four points that are not in the same plane, and push four faces into **triangleF**, will return **None** if tetrahedron not formed, otherwise return **self**
    - **CleanUp()** will clean up the faces that has been covered during updating faces from old convex hull, saving only edges that need not be ignored
    - **AddPointP()** will add point **p** to old convex hull **hull**, remove covered faces, add new faces to **triangleF**
    - **ExtendConvexHull()** will extend and return the final hull **hull**, type **Convex3D**

###### Visualization Examples

- Point cloud for models, 1000 points

<figure class="half">
    <img src="visualization.png" style="zoom:50%;" /><img src="visualization1.png" style="zoom:20%;" /><img src="visualization2.png" style="zoom:20%;" /><img src="visualization3.png" style="zoom:20%;" />
</figure>

- Random point cloud, 50 points, 500 points, 2000 points

<figure class="half">
    <img src="randomVis1.png" style="zoom:25%;" /><img src="randomVis2.png" style="zoom:25%;" /><img src="randomVis3.png" style="zoom:25%;" />
</figure>

##### Time complexity and runtime with incremental number of points

- The time complexity of the algorithm is O(n^2)

  - For **ExtendConvexHull()**, since we need to iterate through all vertices of previous convex hull, we will have the following growth in iteration:

  - $$
    O(3+4+...+n) = O(n^2)
    $$

  - For other parts of the algorithm, the time complexity all are smaller than O(n^2)

  - Thus time complexity is O(n^2)

- Runtime within incremental of points, 10 points, 100 points, 1000 points, 10000 points

  - 10 points: 0.0003941059112548828 s
  - 100 points: 0.024116039276123047 s
  - 1000 points: 0.339540958404541 s
  - 10000 points: 4.90024995803833 s

### Problem 2: Collision Detection for two convex hulls

##### Algorithm and visualizations

- The basic idea of the detection is to see if any edge on one hull will intersect with any plane on the other hull. **I do not consider only one point/edge/face coincide with each other as collisions, only two hulls intersected are considered collide with each other**

  - Testcase 1: two hulls with only one point concides

  - <figure class="half">
        <img src="colVis2_1.png" style="zoom:40%;" /><img src="colVis2_2.png" style="zoom:80%;" />
    </figure>

- **hull.triangleNum** can get a **list<Face> ** of all the hull faces, and **ExtractHullEdges()** can get a **list<Tuple(Point3D, Point3D)>** of all the unrepeatative edges of the convex hull.

- For some special cases, like one convex hull completely encircles another convex hull, or there are no edges intersection but there are point inside another hull, we calculate the volume of a **combined hull** (its point cloud is hull1.points + hull2.points), if **Volume(combinedHull) >= Volume(hull1) + Volume(hull2)**, we can say that two hulls are intersected

  - Testcase 2: One hull encircle another hull completely

  - <figure class="half">
        <img src="colVis5_1.png" style="zoom:40%;" /><img src="colVis5_2.png" style="zoom:80%;" />
    </figure>

  - Testcase 3: Two hulls do not have edge intersection, but there is a point intersection

  - <figure class="half">
        <img src="colVis6_1.png" style="zoom:40%;" /><img src="colVis6_2.png" style="zoom:80%;" />
    </figure>

- For each **f<Face>** in **hull.triangleNum**, we check for each edge **e<Tuple(Point3D, Point3D)>** to see if its two points has different sign of **DirectedVolume()**, if so, it may indicate two hulls intersected, we can be more sure if we do this process in reverse way, that is to say, we use hull that has been extracted with edges be extracted by face, hull that has been extracted with face be extracted by edges

- To Judge if two points of an edge has different sign of **DirectedVolume()**, there is a case that the edge go across the whole another convex hull, in this case we need to truncate the edge, use middle point and one point that is closer to plane as new edge for judgement, truncate time can be determined by parameter **persision**

  - Testcase 4: Two hulls that collide, there are points on one hull inside another hull

  - <figure class="half">
        <img src="colVis3_1.png" style="zoom:35%;" /><img src="colVis3_2.png" style="zoom:80%;" />
    </figure>

  - Testcase 5: Two hulls that collide, there are no points on one hull inside another hull

  - <figure class="half">
        <img src="colVis4_1.png" style="zoom:50%;" /><img src="colVis4_2.png" style="zoom:80%;" />
    </figure>

  - Testcase 6: Two hulls that do not collide

  - <figure class="half">
        <img src="colVis1_1.png" style="zoom:40%;" /><img src="colVis1_2.png" style="zoom:80%;" />
    </figure>

##### Time complexity and runtime with incremental number of points

- The time complexity of the algorithm is O(mn^2)

  - For the process of checking intersection of edge and face in two convex hulls, since we need to iterate through all faces of one convex hull, mark its number as **m**, and for the edges, consider number of points in input point cloud (**n**), the largest number of edges is of O(n^2), thus the complexity is O(mn^2)
  - For other parts of the algorithm, the time complexity all are smaller or eaqual to O(n^2)
  - Thus time complexity is O(mn^2)

- Runtime within incremental of points, 10 points, 100 points, 1000 points, 10000 points

  - 10 points: 0.017806053161621094 s
  - 100 points: 0.20910096168518066 s
  - 1000 points: 3.4112141132354736 s
  - 10000 points: 27.486409902572632 s

##### Optimizations

- Directly break if volume calculation fits the condition, it will save the time for edge checking and aviod misjudge of collision
- Directly break if find one edge intersect with a face, for convex hulls, it has little chance of reaching the worst case senario